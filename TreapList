import java.util.Random;
import javafx.util.Pair;
// A Treap Node
private class TreapNode<E>
{
    E data;
    int priority;
    int treecount;
    TreapNode left, right;
 
    // constructor
    TreapNode(E data)
    {
        this.treecount=0;
        this.data = data;
        this.priority = new Random().nextInt(100);
        this.left = this.right = null;
    }
}
 
class TreapList<E>
{
    TreapNode root;
    public TreapList<E>(){
        this.root=null;

    }

    /* Function to left-rotate a given treap
 
          r                         R
         / \      Left Rotate      / \
        L   R        ———>         r   Y
           / \                   / \
          X   Y                 L   X
    */
    public static TreapNode rotateLeft(TreapNode root)
    {
        TreapNode R = root.right;
        TreapNode X = root.right.left;
 
        // rotate
        R.left = root;
        root.right = X;
 
        // set a new root
        return R;
    }
 
    /* Function to right-rotate a given treap
 
            r                        L
           / \     Right Rotate     / \
          L   R        ———>        X   r
         / \                          / \
        X   Y                        Y   R
    */
    public static TreapNode rotateRight(TreapNode root)
    {
        TreapNode L = root.left;
        TreapNode Y = root.left.right;
 
        // rotate
        L.right = root;
        root.left = Y;
 
        // set a new root
        return L;
    }
 
    
    public void add(int index, E data){
        root=add(this.root, index, data);
            this.root=root;
    }
     // Recursive function to insert a given key with a priority into treap
     //returns the base of the tree after completion
      private TreapNode add(TreapNode root, int index, E data)
    {
        // base case
        if (root == null) {
            return new TreapNode(data);
        }
 
        // if data is less than the root node, insert in the left subtree;
        // otherwise, insert in the right subtree
        if(root.left!=null){
        if (index<= root.left.treecount)
        {
            root.left = add(root.left, index, data);
 
            // rotate right if heap property is violated
             if (root.left != null && root.left.priority > root.priority) {
                root = rotateRight(root);
            }

        }
        else{
            index=index-root.left.treecount;
        }
        
    }
    else if(index==0){
        root.left = add(root.left, index, data);

    }


        else {
            root.right = insertNode(root.right, index-1, data);
 
            // rotate left if heap property is violated
            if (root.right != null && root.right.priority > root.priority) {
                root = rotateLeft(root);
            }
        }
        root.treecount++;
        return root;
    }
    // Recursive function to search for a key in a given treap
    public E get(int index){
        return searchnode(this.root, index );
    }
    private E searchNode(TreapNode root, int key)
    {
        // if the key is not present in the tree
        if (root == null) {
            return false;
        }
 
        // if the key is found

 
        // if the key is less than the root node, search in the left subtree
        if (root.left!=null){
        if(key < root.left.treecount) {
            return searchNode(root.left, key);
        }
        key-=root.left.treecount;
    }
        if (key==0) {
            return root.data;
        } 
        // otherwise, search in the right subtree
        return searchNode(root.right, key-1);
    }
 
    // Recursive function to search for a key in a given treap
    /**private boolean searchNode(TreapNode root, int key)
    {
        // if the key is not present in the tree
        if (root == null) {
            return false;
        }
 
        // if the key is found
        if (root.data == key) {
            return true;
        }
 
        // if the key is less than the root node, search in the left subtree
        if (key < root.data) {
            return searchNode(root.left, key);
        }
 
        // otherwise, search in the right subtree
        return searchNode(root.right, key);
    }*/
public void clear(){
    this.root=null;
}
    
 // Recursive function to delete a key from a given treap
    public E remove(int index){
        return deleteNode(this.root, index).getValue();
    }
    private  Pair<TreapNode,E> deleteNode(TreapNode root, int key)
    {
        if (root == null) {
            return null;
        }
        E data;
 
        // if the key is found

 
        // if the key is less than the root node, search in the left subtree
        if (root.left!=null){
        if(key < root.left.treecount) {
            Pair<TreapNode,E> returns=deleteNode(root.left, key);
            root.left=returns.getkey();
            data=returns.getValue();

        }
        else{key-=root.left.treecount;}
        }
        if(key==0) {
            data=root.data;
            // Case 1: node to be deleted has no children (it is a leaf node)
            if (root.left == null && root.right == null)
            {
                // deallocate the memory and update root to null
                root = null;
            }
 
            // Case 2: node to be deleted has two children
            else if (root.left != null && root.right != null)
            {
                // if the left child has less priority than the right child
                if (root.left.priority < root.right.priority)
                {
                    // call `rotateLeft()` on the root
                    root = rotateLeft(root);
 
                    // recursively delete the left child
                    root.left = deleteNode(root.left, 0).getkey();
                }
                else {
                    // call `rotateRight()` on the root
                    root = rotateRight(root);
 
                    // recursively delete the right child
                    root.right = deleteNode(root.right, 0).getkey();
                }
            }
 
            // Case 3: node to be deleted has only one child
            else {
                // choose a child node
                TreapNode child = (root.left != null)? root.left: root.right;
                root = child;
            }
        }
    

       else  {
        Pair<TreapNode,E> returns=deleteNode(root.right, key);
        root.right=returns.getkey();
        data=returns.getValue();
        }
 
        // if the key is found
       
        root.treecount--;
        return new pair<Treapnode, E>(root, data);
    }
    public int size(){
        return this.root.treecount;
    }
 
    // Utility function to print two-dimensional view of a treap using
    // reverse inorder traversal
    public String printTreap(TreapNode root, int space)
    {
        final int height = 10;
        String returnvalue=null;
 
        // Base case
        if (root == null) {
            return;
        }
 
        // increase distance between levels
        space += height;
 
        // print the left child first
        returnvalue+=printTreap(root.left, space);
        System.lineSeparator();
 
        // print the current node after padding with spaces
        for (int i = height; i < space; i++) {
            returnvalue+=', ';
        }
 
        returnvalue+=(root.data + "[" + root.priority + "]\n");
 
        // print the left child
        System.lineSeparator();
        returnvalue+=printTreap(root.right, space);
        return returnvalue;
    }
 /** 
    public static void main(String[] args)
    {
        // Treap keys
        int[] keys = { 5, 2, 1, 4, 9, 8, 10 };
 
        // construct a treap
        TreapNode root = null;
        for (int key: keys) {
            root = insertNode(root, key);
        }
 
        System.out.println("Constructed treap:\n\n");
        printTreap(root, 0);
 
        System.out.println("\nDeleting node 1:\n\n");
        root = deleteNode(root, 1);
        printTreap(root, 0);
 
        System.out.println("\nDeleting node 5:\n\n");
        root = deleteNode(root, 5);
        printTreap(root, 0);
 
        System.out.println("\nDeleting node 9:\n\n");
        root = deleteNode(root, 9);
        printTreap(root, 0);
    }*/
}
